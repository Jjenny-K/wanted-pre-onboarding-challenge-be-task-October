## Q. 동시에 같은 `DB Table row` 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.

> ### '동시에 같은 'DB Table row'를 업데이트 하는 상황' == DB 동시성(Concurrency) 문제
- 하나의 CPU 코어에서 시간 분할을 통해 여러 일을 처리하는 것처럼 보여지게 하는 기법  
    => 여러 요청이 동시에 동일한 자원에 접근하고 수정하려는 것


- **DB 동시성이 발생할 경우, <u>데이터의 무결성이 깨지고 의도하지 않은 결과 반환</u>**

## 해결방법
> 비관적 가정: 언제든지 다른 요청에 의해 같은 데이터가 동시에 수정할 가능성이 있다
- 데이터를 읽는 시점에 Lock을 걸고, 트랜잭션이 완료될 때까지 Lock 유지
    - 장점: 데이터의 무결성을 완벽히 지킬 수 있음
    - 단점: 이후 다른 요청은 대기 상태로 유지되어 심각한 성능 저하 초래할 수 있음
    

- 데이터베이스 트랜잭션 격리 수준을 repeatable read, serializable 중 하나로 수정해 격리 수준을 더 높인다.
- select for update()를 활용해 트랜잭션이 완료될 때까지 임의의 쿼리 셋에 Lock을 건다.
- cache를 이용해 Lock을 건다.

> 낙관적 가정: 다른 요청에 의해 같은 데이터가 동시에 수정할 가능성은 없다
- 데이터를 읽는 시점에 Lock을 걸지 않고, 수정 시점에 값이 변경되었는지 확인
    - 장점: 값이 변경되었는지 확인할 컬럼을 추가하는 것으로 구현이 비교적 쉬움
    - 단점: 두 개의 세션에서 동일 버전으로 수정할 때 버전 충돌이 발생할 수 있음
    

- 모델에 version, updated_at 중 하나의 컬럼을 추가해 데이터를 수정할 때 해당 컬럼을 갱신해 수정 유무를 확인한다.

### References
@https://velog.io/@combi_jihoon/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-DB-Concurrency  
@https://sabarada.tistory.com/175?category=822063  
